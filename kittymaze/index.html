<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rainbow Cat: Pro Mobile</title>
    <style>
        /* --- CORE LAYOUT --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif;
            touch-action: none; /* Prevents browser zooming/scrolling */
            user-select: none;
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }

        /* 1. BACKGROUND LAYER */
        #rainbow-bg {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
            background: linear-gradient(45deg, #ff9a9e, #fad0c4, #fad0c4, #a18cd1, #fbc2eb, #8fd3f4);
            background-size: 400% 400%;
            animation: rainbowMove 15s ease infinite;
            transition: filter 1.0s ease;
        }
        #rainbow-bg.spirit-mode { filter: grayscale(100%) brightness(15%); }

        @keyframes rainbowMove {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* 2. TOP HEADER (Compact) */
        #top-ui {
            flex: 0 0 auto; /* Don't grow */
            background: rgba(255, 255, 255, 0.9);
            padding: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 10;
        }

        .score-row {
            font-size: 1.0rem;
            color: #6c5ce7;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .button-row {
            display: flex;
            gap: 5px;
        }

        .mini-btn {
            background: #fff;
            border: 1px solid #ff6b6b;
            color: #ff6b6b;
            padding: 4px 10px;
            font-size: 0.8rem;
            border-radius: 12px;
            font-weight: bold;
        }
        .mini-btn.active { background: #ff6b6b; color: white; }
        .mini-btn-new { background: #ffeaa7; border-color: #fdcb6e; color: #d35400; }

        /* 3. GAME AREA (Flexible) */
        #game-area {
            flex: 1 1 auto; /* Grow to fill space */
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            padding: 10px;
        }

        canvas {
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            /* Maximize fit but keep aspect ratio */
            max-width: 100%;
            max-height: 100%; 
            object-fit: contain;
        }

        /* 4. BOTTOM CONTROLS (Fixed Height) */
        #bottom-controls {
            flex: 0 0 180px; /* Dedicated control height */
            position: relative;
            width: 100%;
            display: flex;
            justify-content: space-between; /* Joystick Left, Button Right */
            align-items: center;
            padding: 0 20px;
            box-sizing: border-box;
            /* Optional: slight gradient to indicate control zone */
            background: linear-gradient(to top, rgba(0,0,0,0.1), transparent);
        }

        /* JOYSTICK */
        #joystick-container {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            position: relative;
            touch-action: none;
        }
        
        #joystick-knob {
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 50%;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            pointer-events: none; /* Let clicks pass to container */
        }

        /* ACTION BUTTON */
        #ghost-action-btn {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: #dfe6e9;
            border: 4px solid #b2bec3;
            color: #636e72;
            font-size: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 0 #b2bec3;
            font-weight: bold;
            transition: all 0.1s;
        }
        
        #ghost-action-btn:active {
            transform: translateY(6px);
            box-shadow: none;
        }

        #ghost-action-btn.active-ghost {
            background: #74b9ff;
            border-color: #0984e3;
            color: white;
            box-shadow: 0 0 20px #74b9ff, 0 6px 0 #0984e3;
            text-shadow: 0 0 10px white;
        }

        #ghost-count-display {
            font-size: 1rem;
            margin-top: 5px;
        }

        /* OVERLAYS & EFFECTS */
        #start-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(108, 92, 231, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: white;
            text-align: center;
        }
        #start-button {
            background: #55efc4; color: #2d3436; border: none;
            padding: 20px 50px; font-size: 2rem; border-radius: 50px;
            box-shadow: 0 8px 0 #00b894; font-weight: bold; margin-top: 20px;
        }

        #win-msg { 
            display: none; position: absolute; 
            top: 50%; left: 50%; transform: translate(-50%, -50%); 
            font-size: 3rem; color: #ff6b6b; 
            text-shadow: 3px 3px 0px #fff; font-weight: bold; 
            pointer-events: none; z-index: 20; text-align: center; width: 100%; 
        }

        .shake-effect { animation: shake 0.5s; animation-iteration-count: 1; }
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); } 20% { transform: translate(-3px, 0px) rotate(1deg); } 40% { transform: translate(1px, -1px) rotate(1deg); } 60% { transform: translate(-3px, 1px) rotate(0deg); } 80% { transform: translate(-1px, -1px) rotate(1deg); } 100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

    </style>
</head>
<body>

    <div id="rainbow-bg"></div>

    <div id="start-overlay">
        <h1>üê± Rainbow Cat Maze</h1>
        <p>Pro Mobile Edition</p>
        <button id="start-button" onclick="startGame()">‚ñ∂ START</button>
    </div>

    <div id="top-ui">
        <div class="score-row">
            üíñ <span id="score-val">0</span> | üëë <span id="high-score-val">0</span>
        </div>
        <div class="button-row">
            <button class="mini-btn" id="btn-easy" onclick="setDifficulty('easy')">Easy</button>
            <button class="mini-btn active" id="btn-med" onclick="setDifficulty('medium')">Med</button>
            <button class="mini-btn" id="btn-hard" onclick="setDifficulty('hard')">Hard</button>
            <button class="mini-btn mini-btn-new" onclick="resetGame()">üîÑ New</button>
        </div>
    </div>

    <div id="game-area">
        <canvas id="mazeCanvas"></canvas>
        <div id="win-msg">YAY! üéâ</div>
    </div>

    <div id="bottom-controls">
        <div id="joystick-container">
            <div id="joystick-knob"></div>
        </div>

        <button id="ghost-action-btn" onclick="activateGhostMode()">
            üëª
            <span id="ghost-count-display">x1</span>
        </button>
    </div>

<script>
/* ================= AUDIO SYSTEM ================= */
const audioMeow = new Audio('meow.mp3');
const audioWoof = new Audio('woof.mp3');
const audioOhNo = new Audio('ohno.mp3');
const audioWoo  = new Audio('woo.mp3');
let audioInitialized = false;
let lastWoofTime = 0; 

function initAudio() {
    if (audioInitialized) return;
    [audioMeow, audioWoof, audioOhNo, audioWoo].forEach(snd => {
        snd.volume = 0; 
        snd.play().then(() => {
            snd.pause(); snd.currentTime = 0; snd.volume = 1; 
        }).catch(e => {});
    });
    audioInitialized = true;
}
function playSound(sound) {
    if (!audioInitialized) return;
    try { sound.currentTime = 0; sound.play().catch(e=>{}); } catch(e){}
}

/* ================= GAME STATE & CONFIG ================= */
const canvas = document.getElementById('mazeCanvas');
const ctx = canvas.getContext('2d');
const gameArea = document.getElementById('game-area');
const backgroundLayer = document.getElementById('rainbow-bg');
const ghostBtn = document.getElementById('ghost-action-btn');
const ghostCountEl = document.getElementById('ghost-count-display');

let GRID_SIZE = 21; 
let TILE_SIZE = 0;
let maze = [];     
let collectibles = [];
let enemies = []; 
let score = 0;
let difficulty = 'medium';
let highScore = localStorage.getItem('catMazeHighScore') || 0;
document.getElementById('high-score-val').innerText = highScore;

// Player & Movement
let player = { x: 0, y: 0, size: 0, speed: 0 };
let joystickInput = { x: 0, y: 0 }; // Values from -1.0 to 1.0
let keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

// Ghost Mode
let ghostCharges = 1;
let isGhost = false;
let ghostTimer = null;
let gameRunning = false;
let gameWon = false;
let confettiParticles = [];

const WALL_COLORS = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEEAD', '#D4A5A5'];
const COLLECTIBLE_TYPES = ['üêü', 'üß∂', 'üê≠'];

/* ================= JOYSTICK LOGIC ================= */
const joyContainer = document.getElementById('joystick-container');
const joyKnob = document.getElementById('joystick-knob');
let joyActive = false;
let joyCenter = { x: 0, y: 0 };
const maxRadius = 35; // Maximum distance knob can move

joyContainer.addEventListener('touchstart', startJoystick, {passive: false});
joyContainer.addEventListener('touchmove', moveJoystick, {passive: false});
joyContainer.addEventListener('touchend', endJoystick, {passive: false});
// Mouse support for testing on PC
joyContainer.addEventListener('mousedown', startJoystick);
window.addEventListener('mousemove', moveJoystick);
window.addEventListener('mouseup', endJoystick);

function startJoystick(e) {
    e.preventDefault();
    joyActive = true;
    const rect = joyContainer.getBoundingClientRect();
    joyCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
    moveJoystick(e);
}

function moveJoystick(e) {
    if (!joyActive) return;
    if (e.type === 'touchmove') e.preventDefault(); // Prevent scroll

    let clientX, clientY;
    if (e.touches) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; } 
    else { clientX = e.clientX; clientY = e.clientY; }

    const dx = clientX - joyCenter.x;
    const dy = clientY - joyCenter.y;
    const distance = Math.min(Math.hypot(dx, dy), maxRadius);
    const angle = Math.atan2(dy, dx);

    // Visual: Move Knob
    const knobX = Math.cos(angle) * distance;
    const knobY = Math.sin(angle) * distance;
    joyKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;

    // Logic: Normalize input (-1 to 1)
    joystickInput.x = knobX / maxRadius;
    joystickInput.y = knobY / maxRadius;
}

function endJoystick(e) {
    if(e.preventDefault) e.preventDefault();
    joyActive = false;
    joystickInput = { x: 0, y: 0 };
    joyKnob.style.transform = `translate(-50%, -50%)`;
}

/* ================= MAIN GAME LOOPS ================= */
function startGame() {
    initAudio();
    document.getElementById('start-overlay').style.display = 'none';
    setDifficulty('medium');
}

function setDifficulty(level) {
    document.querySelectorAll('.mini-btn').forEach(b => b.classList.remove('active'));
    if (level === 'easy') { GRID_SIZE = 15; document.getElementById('btn-easy').classList.add('active'); }
    else if (level === 'medium') { GRID_SIZE = 25; document.getElementById('btn-med').classList.add('active'); }
    else if (level === 'hard') { GRID_SIZE = 41; document.getElementById('btn-hard').classList.add('active'); }
    difficulty = level;
    resetGame();
}

// INTELLIGENT RESIZE
function resize() {
    // We calculate size based on the #game-area div, which flexbox has already sized for us
    const rect = gameArea.getBoundingClientRect();
    const availableW = rect.width;
    const availableH = rect.height;
    
    // Determine the biggest square that fits
    let size = Math.min(availableW, availableH) - 10; // -10 for padding
    size = Math.floor(size / GRID_SIZE) * GRID_SIZE; // Snap to grid

    canvas.width = size;
    canvas.height = size;
    TILE_SIZE = size / GRID_SIZE;
    
    player.size = TILE_SIZE * 0.7;
    player.speed = TILE_SIZE * 0.15;
}

function resetGame() {
    gameRunning = true;
    gameWon = false;
    document.getElementById('win-msg').style.display = 'none';
    score = 0; document.getElementById('score-val').innerText = 0;
    
    ghostCharges = 1;
    ghostCountEl.innerText = "x" + ghostCharges;
    stopGhostMode();

    collectibles = [];
    enemies = [];
    
    resize();
    generateMaze();
    spawnCollectibles();
    spawnEnemies();
    
    const midRow = Math.floor(GRID_SIZE/2);
    player.x = 0; 
    player.y = midRow * TILE_SIZE + (TILE_SIZE - player.size)/2;

    requestAnimationFrame(loop);
}

function activateGhostMode() {
    if (isGhost || ghostCharges <= 0 || gameWon) return;
    ghostCharges--;
    ghostCountEl.innerText = "x" + ghostCharges;
    score -= 10;
    document.getElementById('score-val').innerText = score;
    isGhost = true;
    
    ghostBtn.classList.add('active-ghost');
    backgroundLayer.classList.add('spirit-mode');
    
    playSound(audioWoo);
    if (ghostTimer) clearTimeout(ghostTimer);
    ghostTimer = setTimeout(stopGhostMode, 10500);
}

function stopGhostMode() {
    isGhost = false;
    ghostBtn.classList.remove('active-ghost');
    backgroundLayer.classList.remove('spirit-mode');
    audioWoo.pause();
    if (ghostTimer) clearTimeout(ghostTimer);
}

/* ================= LOGIC & PHYSICS ================= */
function update() {
    if (gameWon) { updateConfetti(); return; }
    if (!gameRunning) return;

    // MERGE INPUTS (Joystick + Keyboard)
    let vx = joystickInput.x * player.speed;
    let vy = joystickInput.y * player.speed;

    if (Math.abs(vx) < 0.1 && Math.abs(vy) < 0.1) {
        // Fallback to keyboard if joystick is idle
        if (keys.ArrowUp) vy = -player.speed;
        if (keys.ArrowDown) vy = player.speed;
        if (keys.ArrowLeft) vx = -player.speed;
        if (keys.ArrowRight) vx = player.speed;
    }

    // Move X
    if (!checkWallCollision(player.x + vx, player.y)) player.x += vx;
    // Move Y
    if (!checkWallCollision(player.x, player.y + vy)) player.y += vy;

    updateEnemies();
    checkCollectibles();

    if (player.x > canvas.width - TILE_SIZE) winGame();
}

function updateEnemies() {
    const proximity = TILE_SIZE * 3; 
    let dogNearby = false;

    enemies.forEach(dog => {
        // Simple random patrol logic
        if (dog.vx === 0 && dog.vy === 0 || checkWallCollision(dog.x + dog.vx, dog.y + dog.vy)) {
            const dirs = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];
            const valid = dirs.filter(d => !checkWallCollision(dog.x + d.x*dog.speed, dog.y + d.y*dog.speed));
            if (valid.length > 0) {
                const pick = valid[Math.floor(Math.random() * valid.length)];
                dog.vx = pick.x * dog.speed;
                dog.vy = pick.y * dog.speed;
            } else {
                dog.vx = -dog.vx; dog.vy = -dog.vy;
            }
        }
        dog.x += dog.vx;
        dog.y += dog.vy;

        const dist = Math.hypot(player.x - dog.x, player.y - dog.y);
        if (!isGhost && dist < player.size * 0.8) caughtByDog();
        if (dist < proximity) dogNearby = true;
    });

    if (dogNearby && !isGhost) {
        if (Date.now() - lastWoofTime > 2000) { playSound(audioWoof); lastWoofTime = Date.now(); }
    }
}

function caughtByDog() {
    playSound(audioOhNo);
    canvas.classList.remove('shake-effect'); void canvas.offsetWidth; canvas.classList.add('shake-effect');
    stopGhostMode();
    const midRow = Math.floor(GRID_SIZE/2);
    player.x = 0; player.y = midRow * TILE_SIZE + (TILE_SIZE - player.size)/2;
}

function checkWallCollision(x, y) {
    // Check 4 corners of player box
    const margin = 2; // slight forgiveness
    const points = [
        {x: x+margin, y: y+margin}, 
        {x: x + player.size-margin, y: y+margin},
        {x: x+margin, y: y + player.size-margin}, 
        {x: x + player.size-margin, y: y + player.size-margin}
    ];
    for (let p of points) {
        const c = Math.floor(p.x / TILE_SIZE);
        const r = Math.floor(p.y / TILE_SIZE);
        if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE) {
            if (maze[r][c] === 1) return true;
        }
    }
    return false;
}

function checkCollectibles() {
    const cx = player.x + player.size/2, cy = player.y + player.size/2;
    collectibles.forEach(item => {
        if (!item.collected && Math.hypot(cx - item.x, cy - item.y) < TILE_SIZE/1.5) {
            item.collected = true;
            score += 10;
            ghostCharges++;
            ghostCountEl.innerText = "x" + ghostCharges;
            document.getElementById('score-val').innerText = score;
            playSound(audioMeow);
        }
    });
}

/* ================= MAZE GEN ================= */
function generateMaze() {
    maze = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(1));
    carve(1, 1);
    const mid = Math.floor(GRID_SIZE/2);
    maze[mid][0] = 0; maze[mid][1] = 0; maze[mid][GRID_SIZE-1] = 0; maze[mid][GRID_SIZE-2] = 0;
}
function carve(x, y) {
    const dirs = [[0, -2], [0, 2], [-2, 0], [2, 0]].sort(() => Math.random() - 0.5);
    maze[y][x] = 0;
    for (let d of dirs) {
        const nx = x + d[0], ny = y + d[1];
        if (nx > 0 && nx < GRID_SIZE-1 && ny > 0 && ny < GRID_SIZE-1 && maze[ny][nx]===1) {
            maze[y+d[1]/2][x+d[0]/2] = 0;
            carve(nx, ny);
        }
    }
}
function spawnCollectibles() {
    let count = difficulty === 'hard' ? 20 : (difficulty === 'medium' ? 10 : 5);
    for(let i=0; i<count; i++) spawnEntity((c,r)=> collectibles.push({x: c*TILE_SIZE+TILE_SIZE/2, y: r*TILE_SIZE+TILE_SIZE/2, type: COLLECTIBLE_TYPES[Math.floor(Math.random()*3)], collected: false}));
}
function spawnEnemies() {
    let count = difficulty === 'hard' ? 12 : (difficulty === 'medium' ? 5 : 2);
    for(let i=0; i<count; i++) spawnEntity((c,r)=> {
        if(c>4) enemies.push({x: c*TILE_SIZE+(TILE_SIZE-player.size)/2, y: r*TILE_SIZE+(TILE_SIZE-player.size)/2, vx:0, vy:0, speed: player.speed*0.4});
    });
}
function spawnEntity(cb) {
    let placed=false; while(!placed){
        let r=Math.floor(Math.random()*GRID_SIZE), c=Math.floor(Math.random()*GRID_SIZE);
        if(maze[r][c]===0){ cb(c,r); placed=true; }
    }
}

/* ================= DRAW ================= */
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // BACKGROUND
    ctx.fillStyle = isGhost ? 'rgba(20,20,20,0.85)' : 'rgba(255,255,255,0.4)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // WALLS
    for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
            if (maze[r][c] === 1) {
                ctx.fillStyle = WALL_COLORS[(r * c + r) % WALL_COLORS.length];
                ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE + 1, TILE_SIZE + 1);
            }
        }
    }

    // ITEMS
    ctx.font = `${TILE_SIZE * 0.6}px Arial`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    collectibles.forEach(i => { if (!i.collected) ctx.fillText(i.type, i.x, i.y); });

    // ENEMIES
    ctx.save();
    if (isGhost) { ctx.shadowBlur = 30; ctx.shadowColor = '#ff0055'; }
    ctx.font = `${player.size}px Arial`;
    enemies.forEach(d => {
        ctx.save();
        ctx.translate(d.x + player.size/2, d.y + player.size/2);
        if (d.vx < 0) ctx.scale(-1, 1);
        ctx.fillText('üê∂', 0, 0);
        ctx.restore();
    });
    ctx.restore();

    // PLAYER
    ctx.save();
    if (isGhost) { ctx.filter = 'grayscale(100%) brightness(500%)'; ctx.shadowBlur = 40; ctx.shadowColor = '#fff'; }
    ctx.fillText('üê±', player.x + player.size/2, player.y + player.size/2);
    ctx.restore();

    if (gameWon) drawConfetti();
}

function loop() { update(); draw(); requestAnimationFrame(loop); }
function winGame() {
    gameWon = true; 
    document.getElementById('win-msg').style.display = 'block';
    if(score>highScore){ highScore=score; localStorage.setItem('catMazeHighScore',highScore); document.getElementById('high-score-val').innerText=highScore; }
    createConfetti();
}
function createConfetti() { for(let i=0;i<100;i++) confettiParticles.push({x:canvas.width/2,y:canvas.height/2,vx:(Math.random()-0.5)*15,vy:(Math.random()-0.5)*15,c:WALL_COLORS[Math.floor(Math.random()*6)],s:Math.random()*8+4}); }
function updateConfetti() { confettiParticles.forEach(p=>{p.x+=p.vx;p.y+=p.vy;p.vy+=0.2;}); }
function drawConfetti() { confettiParticles.forEach(p=>{ctx.fillStyle=p.c;ctx.fillRect(p.x,p.y,p.s,p.s)}); }

// Keyboard Support
window.addEventListener('keydown', e => { if(e.code==='Space') activateGhostMode(); if(keys.hasOwnProperty(e.code)) keys[e.code]=true; });
window.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.code)) keys[e.code]=false; });
window.addEventListener('resize', () => { if(gameRunning) resize(); });

</script>
</body>
</html>

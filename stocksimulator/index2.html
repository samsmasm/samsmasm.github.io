<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stock Simulator</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --text: #e5e7eb;
      --muted: #94a3b8;
      --accent: #38bdf8;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
    }

    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      padding: 16px 16px 28px;
    }

    .toolbar {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      background: var(--panel);
      padding: 10px 12px;
      border-radius: 14px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, .25);
    }

    .toolbar .group {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .toolbar label {
      font-size: 12px;
      color: var(--muted);
    }

    .toolbar select,
    .toolbar input[type="number"],
    .toolbar input[type="range"] {
      background: #0b1022;
      color: var(--text);
      border: 1px solid #223;
      outline: none;
      border-radius: 10px;
      padding: 6px 8px;
    }

    .toolbar input[type="range"] {
      accent-color: var(--accent);
      height: 6px;
    }

    .btn {
      cursor: pointer;
      border: 1px solid #2a3550;
      background: #0b1022;
      color: var(--text);
      padding: 7px 10px;
      border-radius: 10px;
    }

    .btn:hover {
      border-color: #3e4f80;
    }

    .canvas-card {
      margin-top: 14px;
      background: var(--panel);
      border-radius: 16px;
      box-shadow: 0 12px 28px rgba(0, 0, 0, .25);
      position: relative;
    }

    canvas {
      display: block;
      width: 100%;
      height: 520px;
    }

    .hint {
      position: absolute;
      right: 14px;
      bottom: 10px;
      font-size: 12px;
      color: var(--muted);
    }

    .legend {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 8px;
      color: var(--muted);
      font-size: 13px;
    }

    .badge {
      padding: 2px 6px;
      border-radius: 8px;
      background: #0b1022;
      border: 1px solid #223;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1 style="font-size:20px;margin:4px 0 12px">Stock Simulator</h1>
    <div class="toolbar">
      <div class="group">
        <button class="btn" id="playPauseBtn">Play</button>
        <button class="btn" id="regenBtn">Regenerate</button>
      </div>
      <div class="group" style="min-width:220px">
        <label for="lineSelect">Line</label>
        <select id="lineSelect"></select>
        <button class="btn" id="prevBtn">◀</button>
        <button class="btn" id="nextBtn">▶</button>
      </div>
      <div class="group">
        <label for="viewMode">View</label>
        <select id="viewMode">
          <option value="selected">Selected only</option>
          <option value="faint">Selected + faint others</option>
          <option value="equal">Highlight all equally</option>
        </select>
      </div>
      <div class="group">
        <label for="picker">Pick interesting</label>
        <select id="picker" title="Select a criterion to auto-pick a line">
          <option value="" selected>— choose —</option>
          <option value="straightest">Straightest trajectory (least SSE to best-fit line)</option>
          <option value="range">Greatest top-to-bottom range</option>
          <option value="zero">Most zero-crossings</option>
          <option value="streak">Longest one-direction streak</option>
          <option value="drawdown">Largest max drawdown</option>
          <option value="earliest">Earliest to hit |y| threshold</option>
          <option value="area">Largest area under |y|</option>
        </select>
        <button class="btn" id="applyPick">Find</button>
      </div>
      <div class="group" style="flex:1 1 220px;min-width:220px">
        <label for="scrub">Progress</label>
        <input id="scrub" type="range" min="0" max="100" value="100" style="width:180px" />
      </div>
      <div class="group">
        <label for="linesInput">Lines</label>
        <input id="linesInput" type="number" min="1" max="200" value="50" style="width:70px" />
      </div>
      <div class="group">
        <label for="stepsInput">Steps</label>
        <input id="stepsInput" type="number" min="10" max="1000" value="100" style="width:80px" />
      </div>
      <div class="group">
        <button class="btn" id="applyBtn">Apply</button>
      </div>
    </div>
    <div class="canvas-card">
      <canvas id="chart" width="1100" height="520"></canvas>
      <div class="hint">Scroll to zoom • Drag to pan</div>
    </div>
    <div class="legend" id="legend"></div>
  </div>

  <script>
    function colorFor(i, total) {
      const hue = (i * 360 / Math.max(1, total)) % 360;
      return `hsl(${hue} 85% 60%)`;
    }

    function clamp(n, min, max) {
      return Math.max(min, Math.min(max, n));
    }

    function randNormal() {
      const u = Math.random() || 1e-12;
      const v = Math.random() || 1e-12;
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    }

    const state = {
      lines: 50,
      steps: 100,
      walks: [],
      minY: 0,
      maxY: 0,
      curStep: 100,
      playing: false,
      selected: 0,
      view: 'faint',
      panX: 0,
      panY: 0,
      scaleX: 1,
      scaleY: 1
    };

    const canvas = document.getElementById('chart');
    const ctx = canvas.getContext('2d');
    const lineSelect = document.getElementById('lineSelect');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const viewMode = document.getElementById('viewMode');
    const picker = document.getElementById('picker');
    const applyPick = document.getElementById('applyPick');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const regenBtn = document.getElementById('regenBtn');
    const scrub = document.getElementById('scrub');
    const linesInput = document.getElementById('linesInput');
    const stepsInput = document.getElementById('stepsInput');
    const applyBtn = document.getElementById('applyBtn');
    const legend = document.getElementById('legend');

    function resize() {
      const r = canvas.parentElement.getBoundingClientRect();
      canvas.width = Math.floor(r.width);
      canvas.height = Math.floor(r.height);
      draw();
    }

    window.addEventListener('resize', resize, { passive: true });

    function populateSelect() {
      lineSelect.innerHTML = '';
      for (let i = 0; i < state.lines; i++) {
        const o = document.createElement('option');
        o.value = String(i);
        o.textContent = `Line ${i + 1}`;
        lineSelect.appendChild(o);
      }
      lineSelect.value = String(state.selected);
    }

    function buildLegend() {
      legend.innerHTML = `View: ${viewMode.options[viewMode.selectedIndex].text} | Line ${Number(state.selected) + 1}/${state.lines}`;
    }

    function generate() {
      const { lines, steps } = state;

      state.selected = clamp(state.selected, 0, Math.max(0, lines - 1));
      state.walks = [];
      state.minY = 0;
      state.maxY = 0;

      const mu = 0.00;
      const sigma = 0.20;
      const dt = 1 / steps;

      for (let i = 0; i < lines; i++) {
        let logP = 0;
        const arr = [{ x: 0, y: logP }];

        for (let x = 1; x <= steps; x++) {
          const eps = randNormal();
          const r = mu * dt + sigma * Math.sqrt(dt) * eps;
          logP += r;
          arr.push({ x, y: logP });
          state.minY = Math.min(state.minY, logP);
          state.maxY = Math.max(state.maxY, logP);
        }

        state.walks.push(arr);
      }

      state.curStep = state.steps;
      scrub.max = String(steps);
      scrub.value = String(steps);
      state.panX = 0;
      state.panY = 0;
      state.scaleX = 1;
      state.scaleY = 1;
      populateSelect();
      buildLegend();
      draw();
    }

    function getTransform() {
      const pad = 40;
      const w = canvas.width - pad * 2;
      const h = canvas.height - pad * 2;
      const xMax = Math.max(1, state.steps);
      const yAbsMax = Math.max(1, Math.max(Math.abs(state.minY), Math.abs(state.maxY)));
      const sx = w / xMax;
      const sy = h / (yAbsMax * 2);
      return {
        scaleX: sx * state.scaleX,
        scaleY: sy * state.scaleY,
        originX: pad + state.panX,
        originY: pad + h / 2 + state.panY,
        w,
        h
      };
    }

    function drawGrid(t) {
      const { originX, originY, w, h, scaleX } = t;
      ctx.save();
      ctx.translate(originX, originY);
      ctx.strokeStyle = 'rgba(255,255,255,.05)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let x = 0; x <= state.steps; x += 10) {
        const px = x * scaleX;
        ctx.moveTo(px, -h / 2);
        ctx.lineTo(px, h / 2);
      }
      ctx.stroke();
      ctx.strokeStyle = 'rgba(148,163,184,.6)';
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(state.steps * scaleX, 0);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, -h / 2);
      ctx.lineTo(0, h / 2);
      ctx.stroke();
      ctx.restore();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!state.walks || state.walks.length === 0) {
        buildLegend();
        return;
      }

      const t = getTransform();
      drawGrid(t);
      const stepLimit = Math.min(state.curStep, state.steps);

      function drawOne(path, color, width, alpha) {
        if (!path || path.length === 0) return;
        const { scaleX, scaleY, originX, originY } = t;
        ctx.save();
        ctx.translate(originX, originY);
        ctx.lineWidth = width;
        ctx.strokeStyle = color;
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        const maxI = Math.min(stepLimit, path.length - 1);
        for (let i = 0; i <= maxI; i++) {
          const pt = path[i];
          const px = pt.x * scaleX;
          const py = -pt.y * scaleY;
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.stroke();
        ctx.restore();
      }

      if (state.view === 'faint') {
        for (let i = 0; i < state.walks.length; i++) {
          if (i === state.selected) continue;
          drawOne(state.walks[i], colorFor(i, state.walks.length), 1.2, 0.25);
        }
        drawOne(state.walks[state.selected], colorFor(state.selected, state.walks.length), 2.4, 1);
      } else if (state.view === 'selected') {
        drawOne(state.walks[state.selected], colorFor(state.selected, state.walks.length), 2.4, 1);
      } else if (state.view === 'equal') {
        for (let i = 0; i < state.walks.length; i++) {
          drawOne(state.walks[i], colorFor(i, state.walks.length), 1.5, 0.9);
        }
      }

      buildLegend();
    }

    let raf;

    function loop(ts) {
      if (!state.playing) {
        raf = requestAnimationFrame(loop);
        return;
      }

      state.curStep = Math.min(state.steps, state.curStep + 1);
      scrub.value = String(state.curStep);
      draw();

      if (state.curStep >= state.steps) {
        state.playing = false;
        playPauseBtn.textContent = 'Play';
      }

      raf = requestAnimationFrame(loop);
    }

    playPauseBtn.onclick = () => {
      state.playing = !state.playing;
      playPauseBtn.textContent = state.playing ? 'Pause' : 'Play';
    };

    regenBtn.onclick = () => generate();

    lineSelect.onchange = e => {
      state.selected = Number(e.target.value) || 0;
      draw();
    };

    prevBtn.onclick = () => {
      state.selected = (state.selected - 1 + state.lines) % state.lines;
      lineSelect.value = String(state.selected);
      draw();
    };

    nextBtn.onclick = () => {
      state.selected = (state.selected + 1) % state.lines;
      lineSelect.value = String(state.selected);
      draw();
    };

    viewMode.onchange = e => {
      state.view = e.target.value;
      buildLegend();
      draw();
    };

    scrub.oninput = e => {
      state.curStep = Number(e.target.value) || 0;
      state.playing = false;
      playPauseBtn.textContent = 'Play';
      draw();
    };

    applyBtn.onclick = () => {
      const L = clamp(Number(linesInput.value || 50), 1, 200);
      const S = clamp(Number(stepsInput.value || 100), 10, 1000);
      state.lines = L;
      state.steps = S;

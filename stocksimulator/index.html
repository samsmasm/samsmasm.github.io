<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stock Simulator</title>
  <style>
    :root{
      --bg:#0f172a;
      --panel:#111827;
      --text:#e5e7eb;
      --muted:#94a3b8;
      --accent:#38bdf8;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}
    .wrap{max-width:1100px;margin:0 auto;padding:16px 16px 28px}
    .toolbar{display:flex;gap:12px;flex-wrap:wrap;align-items:center;background:var(--panel);padding:10px 12px;border-radius:14px;box-shadow:0 8px 24px rgba(0,0,0,.25)}
    .toolbar .group{display:flex;gap:8px;align-items:center}
    .toolbar label{font-size:12px;color:var(--muted)}
    .toolbar select,.toolbar input[type="number"],.toolbar input[type="range"]{background:#0b1022;color:var(--text);border:1px solid #223;outline:none;border-radius:10px;padding:6px 8px}
    .toolbar input[type="range"]{accent-color:var(--accent);height:6px}
    .btn{cursor:pointer;border:1px solid #2a3550;background:#0b1022;color:var(--text);padding:7px 10px;border-radius:10px}
    .btn:hover{border-color:#3e4f80}
    .canvas-card{margin-top:14px;background:var(--panel);border-radius:16px;box-shadow:0 12px 28px rgba(0,0,0,.25);position:relative}
    canvas{display:block;width:100%;height:520px}
    .hint{position:absolute;right:14px;bottom:10px;font-size:12px;color:var(--muted)}
    .legend{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-top:8px;color:var(--muted);font-size:13px}
    .badge{padding:2px 6px;border-radius:8px;background:#0b1022;border:1px solid #223}
  </style>
</head>
<body>
  <div class="wrap">
    <h1 style="font-size:20px;margin:4px 0 12px">Stock Simulator</h1>
    <div class="toolbar">
      <div class="group">
        <button class="btn" id="playPauseBtn">Play</button>
        <button class="btn" id="regenBtn">Regenerate</button>
      </div>
      <div class="group" style="min-width:220px">
        <label for="lineSelect">Line</label>
        <select id="lineSelect"></select>
        <button class="btn" id="prevBtn">◀</button>
        <button class="btn" id="nextBtn">▶</button>
      </div>
      <div class="group">
        <label for="viewMode">View</label>
        <select id="viewMode">
          <option value="selected">Selected only</option>
          <option value="faint">Selected + faint others</option>
          <option value="equal">Highlight all equally</option>
        </select>
      </div>
      <div class="group">
        <label for="picker">Pick interesting</label>
        <select id="picker" title="Select a criterion to auto-pick a line">
          <option value="" selected>— choose —</option>
          <option value="straightest">Straightest trajectory (least SSE to best-fit line)</option>
          <option value="range">Greatest top-to-bottom range</option>
          <option value="zero">Most zero-crossings</option>
          <option value="streak">Longest one-direction streak</option>
          <option value="drawdown">Largest max drawdown</option>
          <option value="earliest">Earliest to hit |y| threshold</option>
          <option value="area">Largest area under |y|</option>
        </select>
        <button class="btn" id="applyPick">Find</button>
      </div>
      <div class="group" style="flex:1 1 220px;min-width:220px">
        <label for="scrub">Progress</label>
        <input id="scrub" type="range" min="0" max="100" value="100" style="width:180px" />
      </div>
      <div class="group">
        <label for="linesInput">Lines</label>
        <input id="linesInput" type="number" min="1" max="200" value="50" style="width:70px" />
      </div>
      <div class="group">
        <label for="stepsInput">Steps</label>
        <input id="stepsInput" type="number" min="10" max="1000" value="100" style="width:80px" />
      </div>
      <div class="group">
        <button class="btn" id="applyBtn">Apply</button>
      </div>
    </div>
    <div class="canvas-card">
      <canvas id="chart" width="1100" height="520"></canvas>
      <div class="hint">Scroll to zoom • Drag to pan</div>
    </div>
    <div class="legend" id="legend"></div>
  </div>
  <script>
    function colorFor(i,total){const hue=(i*360/Math.max(1,total))%360;return`hsl(${hue} 85% 60%)`}
    function clamp(n,min,max){return Math.max(min,Math.min(max,n))}

    const state={lines:50,steps:100,walks:[],minY:0,maxY:0,curStep:100,playing:false,selected:0,view:'faint',panX:0,panY:0,scaleX:1,scaleY:1};

    const canvas=document.getElementById('chart');
    const ctx=canvas.getContext('2d');
    const lineSelect=document.getElementById('lineSelect');
    const prevBtn=document.getElementById('prevBtn');
    const nextBtn=document.getElementById('nextBtn');
    const viewMode=document.getElementById('viewMode');
    const picker=document.getElementById('picker');
    const applyPick=document.getElementById('applyPick');
    const playPauseBtn=document.getElementById('playPauseBtn');
    const regenBtn=document.getElementById('regenBtn');
    const scrub=document.getElementById('scrub');
    const linesInput=document.getElementById('linesInput');
    const stepsInput=document.getElementById('stepsInput');
    const applyBtn=document.getElementById('applyBtn');
    const legend=document.getElementById('legend');

    function resize(){const r=canvas.parentElement.getBoundingClientRect();canvas.width=Math.floor(r.width);canvas.height=Math.floor(r.height);draw()}
    window.addEventListener('resize',resize,{passive:true});

    function populateSelect(){lineSelect.innerHTML='';for(let i=0;i<state.lines;i++){const o=document.createElement('option');o.value=String(i);o.textContent=`Line ${i+1}`;lineSelect.appendChild(o);}lineSelect.value=String(state.selected)}

    function buildLegend(){legend.innerHTML=`View: ${viewMode.options[viewMode.selectedIndex].text} | Line ${Number(state.selected)+1}/${state.lines}`;}

    function generate(){const {lines,steps}=state;state.selected=clamp(state.selected,0,Math.max(0,lines-1));state.walks=[];state.minY=0;state.maxY=0;for(let i=0;i<lines;i++){let y=0;const arr=[{x:0,y:0}];for(let x=1;x<=steps;x++){y+=Math.random()<0.5?-1:1;state.minY=Math.min(state.minY,y);state.maxY=Math.max(state.maxY,y);arr.push({x,y});}state.walks.push(arr);}state.curStep=state.steps;scrub.max=String(steps);scrub.value=String(steps);state.panX=0;state.panY=0;state.scaleX=1;state.scaleY=1;populateSelect();buildLegend();draw();}

    function getTransform(){const pad=40,w=canvas.width-pad*2,h=canvas.height-pad*2,xMax=Math.max(1,state.steps),yAbsMax=Math.max(1,Math.max(Math.abs(state.minY),Math.abs(state.maxY))),sx=w/xMax,sy=h/(yAbsMax*2);return{scaleX:sx*state.scaleX,scaleY:sy*state.scaleY,originX:pad+state.panX,originY:pad+h/2+state.panY,w,h}};

    function drawGrid(t){const {originX,originY,w,h,scaleX}=t;ctx.save();ctx.translate(originX,originY);ctx.strokeStyle='rgba(255,255,255,.05)';ctx.lineWidth=1;ctx.beginPath();for(let x=0;x<=state.steps;x+=10){const px=x*scaleX;ctx.moveTo(px,-h/2);ctx.lineTo(px,h/2);}ctx.stroke();ctx.strokeStyle='rgba(148,163,184,.6)';ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(state.steps*scaleX,0);ctx.stroke();ctx.beginPath();ctx.moveTo(0,-h/2);ctx.lineTo(0,h/2);ctx.stroke();ctx.restore();}

    function draw(){ctx.clearRect(0,0,canvas.width,canvas.height);if(!state.walks||state.walks.length===0){buildLegend();return;}const t=getTransform();drawGrid(t);const stepLimit=Math.min(state.curStep,state.steps);function drawOne(path,color,width,alpha){if(!path||path.length===0)return;const {scaleX,scaleY,originX,originY}=t;ctx.save();ctx.translate(originX,originY);ctx.lineWidth=width;ctx.strokeStyle=color;ctx.globalAlpha=alpha;ctx.beginPath();const maxI=Math.min(stepLimit,path.length-1);for(let i=0;i<=maxI;i++){const pt=path[i];const px=pt.x*scaleX;const py=-pt.y*scaleY;if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);}ctx.stroke();ctx.restore();}if(state.view==='faint'){for(let i=0;i<state.walks.length;i++){if(i===state.selected)continue;drawOne(state.walks[i],colorFor(i,state.walks.length),1.2,0.25);}drawOne(state.walks[state.selected],colorFor(state.selected,state.walks.length),2.4,1);}else if(state.view==='selected'){drawOne(state.walks[state.selected],colorFor(state.selected,state.walks.length),2.4,1);}else if(state.view==='equal'){for(let i=0;i<state.walks.length;i++){drawOne(state.walks[i],colorFor(i,state.walks.length),1.5,0.9);}}buildLegend();}

    // ---- Interesting pickers ----
    function bestBy(fn, prefer='max'){
      let bestIdx=0; let bestVal = prefer==='max' ? -Infinity : Infinity;
      for(let i=0;i<state.walks.length;i++){
        const v = fn(state.walks[i]);
        if((prefer==='max' && v>bestVal) || (prefer==='min' && v<bestVal)){
          bestVal=v; bestIdx=i;
        }
      }
      return bestIdx;
    }

    // Straightest: minimize SSE to best-fit line
    function sseToBestFit(path){
      const n=path.length; if(n===0) return Infinity;
      let sumx=0,sumy=0,sumxx=0,sumxy=0;
      for(let i=0;i<n;i++){const x=path[i].x,y=path[i].y; sumx+=x; sumy+=y; sumxx+=x*x; sumxy+=x*y;}
      const denom = n*sumxx - sumx*sumx;
      const b = denom===0 ? 0 : (n*sumxy - sumx*sumy)/denom;
      const a = (sumy - b*sumx)/n;
      let sse=0; for(let i=0;i<n;i++){const x=path[i].x,y=path[i].y; const yhat=a + b*x; const e=y - yhat; sse += e*e;}
      return sse;
    }

    // Range: max y - min y
    const rangeY = (path)=>{ let min=Infinity,max=-Infinity; for(const p of path){ if(p.y<min)min=p.y; if(p.y>max)max=p.y; } return max-min; };

    // Zero-crossings count
    const zeroCross = (path)=>{
      let c=0; for(let i=1;i<path.length;i++){ const a=path[i-1].y, b=path[i].y; if(a===0 && b!==0) c++; else if(a!==0 && b===0) c++; else if(a*b<0) c++; }
      return c;
    };

    // Longest run of +1 or -1 steps
    const longestStreak = (path)=>{
      let best=0, run=0, prev=0; for(let i=1;i<path.length;i++){ const d=path[i].y - path[i-1].y; if(d===0){ run=0; continue; } if(d===prev){ run++; } else { run=1; prev=d; } if(run>best) best=run; } return best;
    };

    // Max drawdown (peak-to-trough)
    const maxDrawdown = (path)=>{ let peak=path[0].y, mdd=0; for(let i=1;i<path.length;i++){ if(path[i].y>peak) peak=path[i].y; const dd=peak - path[i].y; if(dd>mdd) mdd=dd; } return mdd; };

    // Earliest to hit |y| >= T, T = 0.75 * global max |y|
    function earliestHit(path, T){ for(let i=0;i<path.length;i++){ if(Math.abs(path[i].y)>=T) return i; } return Infinity; }

    // Area under |y|
    const areaAbs = (path)=>{ let s=0; for(let i=0;i<path.length;i++){ s += Math.abs(path[i].y); } return s; };

    function pickInteresting(which){
      if(!state.walks.length) return;
      let idx=0;
      if(which==='straightest') idx = bestBy(sseToBestFit,'min');
      else if(which==='range') idx = bestBy(rangeY,'max');
      else if(which==='zero') idx = bestBy(zeroCross,'max');
      else if(which==='streak') idx = bestBy(longestStreak,'max');
      else if(which==='drawdown') idx = bestBy(maxDrawdown,'max');
      else if(which==='earliest'){
        // compute global threshold
        let globalMaxAbs=1; for(const w of state.walks){ for(const p of w){ const a=Math.abs(p.y); if(a>globalMaxAbs) globalMaxAbs=a; } }
        const T = 0.75*globalMaxAbs;
        idx = bestBy((w)=>earliestHit(w,T),'min');
      } else if(which==='area') idx = bestBy(areaAbs,'max');
      state.selected = clamp(idx,0,state.lines-1);
      lineSelect.value = String(state.selected);
      state.view = 'selected';
      viewMode.value = 'selected';
      draw();
    }

    let raf;function loop(ts){if(!state.playing){raf=requestAnimationFrame(loop);return;}state.curStep=Math.min(state.steps,state.curStep+1);scrub.value=String(state.curStep);draw();if(state.curStep>=state.steps){state.playing=false;playPauseBtn.textContent='Play';}raf=requestAnimationFrame(loop)}

    playPauseBtn.onclick=()=>{state.playing=!state.playing;playPauseBtn.textContent=state.playing?'Pause':'Play';};
    regenBtn.onclick=()=>generate();
    lineSelect.onchange=e=>{state.selected=Number(e.target.value)||0;draw();};
    prevBtn.onclick=()=>{state.selected=(state.selected-1+state.lines)%state.lines;lineSelect.value=String(state.selected);draw();};
    nextBtn.onclick=()=>{state.selected=(state.selected+1)%state.lines;lineSelect.value=String(state.selected);draw();};
    viewMode.onchange=e=>{state.view=e.target.value;buildLegend();draw();};
    scrub.oninput=e=>{state.curStep=Number(e.target.value)||0;state.playing=false;playPauseBtn.textContent='Play';draw();};
    applyBtn.onclick=()=>{const L=clamp(Number(linesInput.value||50),1,200);const S=clamp(Number(stepsInput.value||100),10,1000);state.lines=L;state.steps=S;state.selected=clamp(state.selected,0,Math.max(0,L-1));generate();};

    applyPick.onclick=()=>{ const which = picker.value; if(which) pickInteresting(which); };
    picker.onchange=()=>{ /* optional auto-pick on change */ };

    let drag=false,lastX=0,lastY=0;canvas.onmousedown=e=>{drag=true;lastX=e.clientX;lastY=e.clientY;};window.onmouseup=()=>{drag=false;};window.onmousemove=e=>{if(!drag)return;state.panX+=e.clientX-lastX;state.panY+=e.clientY-lastY;lastX=e.clientX;lastY=e.clientY;draw();};canvas.onwheel=e=>{e.preventDefault();const z=e.deltaY<0?1.1:0.9;state.scaleX*=z;state.scaleY*=z;state.scaleX=clamp(state.scaleX,0.2,10);state.scaleY=clamp(state.scaleY,0.2,10);draw();};window.addEventListener('keydown',e=>{if(e.key===' '){e.preventDefault();playPauseBtn.click();}if(e.key==='ArrowLeft'){prevBtn.click();}if(e.key==='ArrowRight'){nextBtn.click();}if(e.key==='g'||e.key==='G'){regenBtn.click();}});

    function init(){resize();generate();cancelAnimationFrame(raf);raf=requestAnimationFrame(loop);}init();
  </script>
</body>
</html>

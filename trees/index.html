<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Forest Evolution</title>
  <link rel="icon" type="image/png" href="/unisamicon2.png">
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    body { overflow: hidden; background: #0a2010; font-family: 'Segoe UI', sans-serif; color: #ddd; }
    canvas { display: block; }

    #ui {
      position: absolute; top: 10px; left: 10px;
      background: rgba(5, 20, 5, 0.84);
      backdrop-filter: blur(6px);
      border: 1px solid rgba(100, 200, 80, 0.25);
      border-radius: 10px;
      padding: 14px;
      width: 288px;
      max-height: 92vh;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: #3a6a2a #0a2010;
    }
    #ui.collapsed { max-height: 44px; overflow: hidden; }
    #ui::-webkit-scrollbar { width: 5px; }
    #ui::-webkit-scrollbar-track { background: #0a2010; }
    #ui::-webkit-scrollbar-thumb { background: #3a6a2a; border-radius: 3px; }

    .row  { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
    h2    { font-size: 14px; font-weight: bold; color: #7ec850; }
    .back { font-size: 11px; color: #7ec850; text-decoration: none; border: 1px solid #3a6a2a;
            border-radius: 5px; padding: 2px 8px; margin-right: 6px; }
    .back:hover { background: #1a4a1a; }
    .tog  { background: none; border: 1px solid #3a6a2a; color: #aaa; border-radius: 4px;
            cursor: pointer; padding: 2px 8px; font-size: 12px; }
    .tog:hover { background: #1a4a1a; }

    .sec  { font-size: 10px; font-weight: bold; text-transform: uppercase; letter-spacing: 0.08em;
            color: #7ec850; border-bottom: 1px solid rgba(126,200,80,0.2);
            padding-bottom: 3px; margin: 10px 0 6px; }
    .stat { display: flex; justify-content: space-between; font-size: 12px; margin: 3px 0; }
    .val  { font-family: monospace; font-weight: bold; color: #b0e880; }

    .ctrl       { margin: 7px 0; }
    .ctrl label { font-size: 11px; color: #ccc; display: flex; justify-content: space-between; margin-bottom: 3px; }
    input[type=range] { width: 100%; accent-color: #7ec850; cursor: pointer; }

    #graph { border: 1px solid rgba(126,200,80,0.2); border-radius: 4px; margin-top: 8px; display: block; }
    .legend { display: flex; flex-wrap: wrap; gap: 5px; font-size: 9px; margin-top: 4px; }
    .leg  { display: flex; align-items: center; gap: 3px; }
    .leg-line { width: 10px; height: 2px; border-radius: 1px; display: inline-block; }

    .trait-key {
      font-size: 9px; color: #888; margin-top: 8px; line-height: 1.6;
      border-top: 1px solid rgba(126,200,80,0.15); padding-top: 6px;
    }
    .trait-key span { color: #aaa; }

    #btn-reset {
      width: 100%; margin-top: 10px; padding: 5px;
      background: rgba(30, 80, 20, 0.6); border: 1px solid #3a6a2a;
      border-radius: 5px; color: #7ec850; font-size: 11px; cursor: pointer;
    }
    #btn-reset:hover { background: rgba(50, 120, 30, 0.7); }

    details.info { margin-top: 10px; }
    details.info summary {
      font-size: 10px; font-weight: bold; text-transform: uppercase;
      letter-spacing: 0.08em; color: #7ec850; cursor: pointer;
      list-style: none; display: flex; align-items: center; gap: 5px;
      padding: 4px 0; border-top: 1px solid rgba(126,200,80,0.2);
      user-select: none;
    }
    details.info summary::before { content: '‚ñ∂'; font-size: 8px; transition: transform 0.15s; }
    details.info[open] summary::before { transform: rotate(90deg); }
    details.info summary::-webkit-details-marker { display: none; }
    .info-trait { font-size: 10px; color: #bbb; margin: 5px 0; line-height: 1.5; }
    .info-trait b { color: #8ed860; }

    #preview-wrap {
      position: absolute; top: 10px; right: 10px;
      background: rgba(5, 20, 5, 0.82);
      backdrop-filter: blur(6px);
      border: 1px solid rgba(100, 200, 80, 0.25);
      border-radius: 10px;
      overflow: hidden;
    }
    #preview-label {
      position: absolute; top: 6px; left: 0; width: 100%;
      text-align: center; font-size: 10px; color: rgba(180,230,140,0.7);
      pointer-events: none; letter-spacing: 0.05em;
    }
  </style>
</head>
<body>

<canvas id="c"></canvas>

<div id="preview-wrap">
  <canvas id="preview"></canvas>
  <div id="preview-label">avg tree</div>
</div>

<div id="ui">
  <div class="row">
    <div style="display:flex;align-items:center">
      <a class="back" href="/">‚Üê Home</a>
      <h2>üå≤ Forest Evolution</h2>
    </div>
    <button class="tog" id="tog">‚ñ≤</button>
  </div>

  <div id="content">
    <div class="sec">World</div>
    <div class="stat">Trees: <span class="val" id="s-pop">0</span></div>
    <div class="stat">Seeds: <span class="val" id="s-seeds">0</span></div>
    <div class="stat">Time:  <span class="val" id="s-time">0</span></div>

    <div class="sec">Physical Traits</div>
    <div class="stat" style="color:#6dbf4a">Height:            <span class="val" id="s-h">‚Äî</span></div>
    <div class="stat" style="color:#a07850">Girth:             <span class="val" id="s-g">‚Äî</span></div>
    <div class="stat" style="color:#b088e0">Canopy width:      <span class="val" id="s-cw">‚Äî</span></div>
    <div class="stat" style="color:#5bc8a0">Root depth:        <span class="val" id="s-r">‚Äî</span></div>
    <div class="stat" style="color:#d08840">Bark thickness:    <span class="val" id="s-b">‚Äî</span></div>

    <canvas id="graph-phys" width="260" height="70"></canvas>
    <div class="legend">
      <span class="leg"><span class="leg-line" style="background:#6dbf4a"></span>H</span>
      <span class="leg"><span class="leg-line" style="background:#a07850"></span>G</span>
      <span class="leg"><span class="leg-line" style="background:#b088e0"></span>CW</span>
      <span class="leg"><span class="leg-line" style="background:#5bc8a0"></span>Root</span>
      <span class="leg"><span class="leg-line" style="background:#d08840"></span>Bark</span>
      <span class="leg"><span class="leg-line" style="background:#fff"></span>Pop</span>
    </div>

    <div class="sec">Strategic Traits</div>
    <div class="stat" style="color:#e8d060">Seed (0=big, 1=many): <span class="val" id="s-s">‚Äî</span></div>
    <div class="stat" style="color:#80c8e0">Dispersal (slots):    <span class="val" id="s-d">‚Äî</span></div>
    <div class="stat" style="color:#c8a030">Allelopathy:          <span class="val" id="s-a">‚Äî</span></div>
    <div class="stat" style="color:#e07050">Serotiny:             <span class="val" id="s-sr">‚Äî</span></div>

    <canvas id="graph-strat" width="260" height="70"></canvas>
    <div class="legend">
      <span class="leg"><span class="leg-line" style="background:#e8d060"></span>Seed</span>
      <span class="leg"><span class="leg-line" style="background:#80c8e0"></span>Disp.</span>
      <span class="leg"><span class="leg-line" style="background:#c8a030"></span>Allelo.</span>
      <span class="leg"><span class="leg-line" style="background:#e07050"></span>Serotiny</span>
      <span class="leg"><span class="leg-line" style="background:#fff"></span>Pop</span>
    </div>

    <div class="trait-key">
      <span>Shape:</span> tall+thin = conifer ¬∑ short+wide = deciduous<br>
      <span>Canopy:</span> width varies independently of girth<br>
      <span>Trunk:</span> cream = thin bark ¬∑ near-black = thick bark<br>
      <span>Colour:</span> dark emerald (s‚âà0) ‚Üí lime-yellow (s‚âà1)<br>
      <span>Roots:</span> visible below ground, depth ‚âà tree height<br>
      <span>Dispersal:</span> blue arc shows seed-reach radius<br>
      <span>Allelo.:</span> yellow-brown dead zone around base<br>
      <span>Serotiny:</span> orange cones / dark pods on canopy
    </div>

    <div class="sec">Climate</div>
    <div class="ctrl">
      <label>Rainfall <span class="val" id="d-rain">0.50</span></label>
      <input type="range" id="sl-rain" min="0" max="1" step="0.05" value="0.5">
    </div>
    <div class="ctrl">
      <label>Wind <span class="val" id="d-wind">0.20</span></label>
      <input type="range" id="sl-wind" min="0" max="1" step="0.05" value="0.2">
    </div>
    <div class="ctrl">
      <label>Fire Rate <span class="val" id="d-fire">0.00</span></label>
      <input type="range" id="sl-fire" min="0" max="1" step="0.05" value="0">
    </div>

    <div class="sec">Simulation</div>
    <div class="ctrl">
      <label>Mutation <span class="val" id="d-mut">0.10</span></label>
      <input type="range" id="sl-mut" min="0" max="1" step="0.05" value="0.1">
    </div>
    <div class="ctrl">
      <label>Speed <span class="val" id="d-speed">1√ó</span></label>
      <input type="range" id="sl-speed" min="1" max="50" step="1" value="1">
    </div>

    <button id="btn-reset">‚Ü∫ Reset</button>

    <details class="info">
      <summary>‚Ñπ About the traits</summary>
      <div class="info-trait"><b>Height (h)</b> Taller trees intercept more light but cost more energy to maintain and are easily wind-toppled. Evolves shorter when wind is strong.</div>
      <div class="info-trait"><b>Girth (g)</b> Wide trunks anchor trees against wind, but are expensive. Key in windy environments.</div>
      <div class="info-trait"><b>Canopy width (cw)</b> How far branches spread, independent of trunk girth. Wide canopies capture more light and cast deeper shade on neighbours, but cost more energy and catch more wind.</div>
      <div class="info-trait"><b>Root depth (r)</b> Deep roots extract water when rainfall is low. Costly to maintain; favoured as rainfall decreases.</div>
      <div class="info-trait"><b>Bark thickness (b)</b> Thick bark resists fire ignition and slows burning. Energetically costly; evolves rapidly when fire rate is high.</div>
      <div class="info-trait"><b>Seed strategy (s)</b> 0 = few large seeds that germinate under shade; 1 = many small seeds that colonise open ground. Affects tree colour (deep vs bright green).</div>
      <div class="info-trait"><b>Dispersal (d)</b> How far seeds travel from the parent. Wind biases the direction. High dispersal finds empty slots; low dispersal clusters offspring nearby.</div>
      <div class="info-trait"><b>Allelopathy (a)</b> Trees produce chemicals that suppress germination in nearby slots. Costs energy; pays off when the forest is dense and slot competition is intense.</div>
      <div class="info-trait"><b>Serotiny (sr)</b> Seeds are sealed in resin cones and released only by fire heat. Useless in fire-free forests; in fire-prone ones each burn floods clearings with stored seeds before competitors can arrive.</div>
    </details>
  </div>
</div>

<script>
'use strict';

// ‚îÄ‚îÄ‚îÄ CONFIG ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const CFG = {
  slotW:      14,
  groundFrac: 0.76,

  rainfall:   0.5,
  windStr:    0.2,
  windDir:    0,        // -1..+1, drifts over time
  fireRate:   0.0,

  mutRate:    0.1,
  simSpeed:   1,

  photoBase:  1.0,
  maintH:     0.20,
  maintG:     0.05,
  maintBase:  0.03,
  reproThr:   200,
  reproCost:  100,
  seedEnergy: 50,
  maxAge:     7000,

  hRange:  [0.15, 1.0],
  gRange:  [0.20, 1.0],
  dRange:  [1,    14],
  cwRange: [0.05, 1.0],  // canopy width gene
};

const SEED_HALFLIFE  = 1200;   // frames until ~37% viability remains
const SEED_MIN_VIA   = 0.004;  // remove seeds below this viability
const MAX_SEED_BANK  = 2000;

// ‚îÄ‚îÄ‚îÄ CANVAS & STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const canvas = document.getElementById('c');
const ctx    = canvas.getContext('2d');

let numSlots = 0, groundY = 0, maxTreeH = 0;
let slots       = [];   // Tree | null per slot
let stumps      = [];   // charred/fallen stump records
let lightArr    = [];   // Float32Array of light levels
let frameCount  = 0;    // simulation frames
let animFrame   = 0;    // render frames (for visual animations)
let history     = [];
const MAX_HIST  = 300;

// New state
let windParticles = [];
let raindrops     = [];
let fallingTrees  = [];
let activeFires   = new Map();  // slot ‚Üí {age, burnTime}
let seedBank      = [];         // {slot, genes, seedSize, age}

// ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const clamp = (v, lo, hi) => v < lo ? lo : v > hi ? hi : v;
const rnd   = (lo, hi)    => lo + Math.random() * (hi - lo);

function mutate(g) {
  const m = CFG.mutRate;
  return {
    h:  clamp(g.h  + (Math.random()-0.5) * m * 0.35, ...CFG.hRange),
    g:  clamp(g.g  + (Math.random()-0.5) * m * 0.35, ...CFG.gRange),
    cw: clamp(g.cw + (Math.random()-0.5) * m * 0.35, ...CFG.cwRange),
    s:  clamp(g.s  + (Math.random()-0.5) * m * 0.50, 0, 1),
    d:  clamp(g.d  + (Math.random()-0.5) * m * 5,    ...CFG.dRange),
    r:  clamp(g.r  + (Math.random()-0.5) * m * 0.35, 0, 1),
    b:  clamp(g.b  + (Math.random()-0.5) * m * 0.35, 0, 1),
    a:  clamp(g.a  + (Math.random()-0.5) * m * 0.35, 0, 1),
    sr: clamp(g.sr + (Math.random()-0.5) * m * 0.35, 0, 1),
  };
}

// ‚îÄ‚îÄ‚îÄ TREE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class Tree {
  constructor(slot, genes = null) {
    this.slot   = slot;
    this.x      = (slot + 0.5) * CFG.slotW;
    this.curH   = 4;
    this.energy = CFG.seedEnergy;
    this.age    = 0;
    this.dead   = false;
    this.windToppled = false;

    this.genes = genes ?? {
      h:  rnd(...CFG.hRange),
      g:  rnd(...CFG.gRange),
      cw: rnd(...CFG.cwRange),
      s:  Math.random(),
      d:  rnd(...CFG.dRange),
      r:  Math.random() * 0.3,   // start low ‚Äî costly to maintain
      b:  Math.random() * 0.3,
      a:  Math.random() * 0.2,
      sr: Math.random() * 0.2,
    };

    this.seedCache = [];  // serotinous seed store, released on fire death

    this.bumps = Array.from({length: 5}, () => ({
      dx:  (Math.random() - 0.5) * 1.5,
      dy: -(Math.random() * 0.85 + 0.1),
      r:    0.22 + Math.random() * 0.16,
    }));
  }

  get targetH()    { return this.genes.h * maxTreeH; }
  get shapeRatio() { return this.genes.h / (this.genes.g + 0.1); }
  get trunkHW() {
    return this.shapeRatio > 2.0
      ? Math.max(1.5, this.genes.g * 4)
      : Math.max(3,   this.genes.g * 11);
  }
  get canopyRX() { return this.genes.cw * 54 + 8; }  // cw gene, not girth
  get canopyRY() { return Math.min(48, this.curH * 0.17 + 5); }

  colors() {
    // s=0: deep emerald (few big seeds, shade-tolerant)
    // s=1: bright lime-yellow (many small seeds, opportunistic)
    const s = this.genes.s;
    const r = Math.round(10  + s * 100);
    const g = Math.round(55  + s * 125);
    const b = Math.round(8   + s * 10);
    return {
      light: `rgb(${r+42},${g+42},${b+14})`,
      mid:   `rgb(${r},${g},${b})`,
      dark:  `rgb(${Math.round(r*0.38)},${Math.round(g*0.38)},${Math.round(b*0.38)})`,
    };
  }

  update(light) {
    this.age++;
    if (this.age > CFG.maxAge) { this.dead = true; return []; }

    // Root depth boosts water access in drought; deep roots cost more to maintain
    const waterAccess = CFG.rainfall + (1 - CFG.rainfall) * this.genes.r * 0.55;
    this.energy += light * waterAccess * CFG.photoBase;

    const hFrac = this.curH / maxTreeH;
    this.energy -= hFrac * CFG.maintH
                 + this.genes.g  * CFG.maintG
                 + this.genes.cw * 0.022   // wide canopy = more leaf area to maintain
                 + CFG.maintBase
                 + this.genes.r  * 0.016   // root maintenance
                 + this.genes.b  * 0.013   // bark production
                 + this.genes.a  * 0.020;  // allelopathic compound synthesis
    if (this.energy <= 0) { this.dead = true; return []; }

    // Wind topple ‚Äî tall/wide-canopied trees most vulnerable; sets windToppled flag
    const vuln = (this.curH / maxTreeH) * (1 + this.genes.cw * 0.7) / (this.genes.g + 0.2);
    if (Math.random() < CFG.windStr * vuln * 0.0025) {
      this.dead = true;
      this.windToppled = true;
      return [];
    }

    if (this.curH < this.targetH) {
      const grow = Math.min(0.9, this.energy * 0.06);
      this.curH   += grow;
      this.energy -= grow * 0.35;
    }

    if (this.energy >= CFG.reproThr) return this.disperse();
    return [];
  }

  disperse() {
    this.energy -= CFG.reproCost;
    const count    = Math.round(1 + this.genes.s * 9 + Math.random() * 2);
    const seedSize = 1 - this.genes.s * 0.75;
    const seeds    = [];
    for (let i = 0; i < count; i++) {
      const bias   = CFG.windDir * CFG.windStr * this.genes.d * 0.4;
      const offset = (Math.random() - 0.5) * 2 * this.genes.d + bias;
      const seed   = { slot: Math.round(this.slot + offset), genes: mutate(this.genes), seedSize };
      // Serotinous trees lock seeds in resin-sealed cones, released only by fire
      if (Math.random() < this.genes.sr && this.seedCache.length < 60) {
        this.seedCache.push(seed);
      } else {
        seeds.push(seed);
      }
    }
    return seeds;
  }

  draw() {
    const c = this.colors();
    if (this.genes.r > 0.15) this._drawRoots();
    if (this.shapeRatio > 2.0) this._drawConifer(c);
    else                        this._drawDeciduous(c);
  }

  // b=0: cream/sandy birch ¬∑ b=1: near-black redwood
  _barkColor() {
    const b  = this.genes.b;
    const rv = Math.round(200 - b * 172);
    const gv = Math.round(155 - b * 143);
    const bv = Math.round(80  - b * 76);
    return `rgb(${rv},${gv},${bv})`;
  }

  // Root lines: depth ‚âà tree height (realistic root:shoot ratio)
  _drawRoots() {
    const r        = this.genes.r;
    const depth    = r * this.curH;   // same scale as tree height
    const numRoots = 2 + Math.round(r * 3);
    const tw       = this.trunkHW;
    const spread   = tw * 2 + r * 30;
    ctx.strokeStyle = `rgba(62,28,6,${(0.4 + r * 0.5).toFixed(2)})`;
    ctx.lineWidth   = 1.2 + r * 2.0;
    const H = canvas.height;
    for (let i = 0; i < numRoots; i++) {
      const frac  = numRoots > 1 ? i / (numRoots - 1) : 0.5;
      const endX  = this.x + (frac - 0.5) * 2 * spread;
      const endY  = Math.min(groundY + depth, H - 2);
      const ctrlY = groundY + depth * 0.45;
      const ctrlX = this.x + (frac - 0.5) * spread;
      ctx.beginPath();
      ctx.moveTo(this.x + (frac - 0.5) * tw, groundY);
      ctx.quadraticCurveTo(ctrlX, ctrlY, endX, endY);
      ctx.stroke();
    }
  }

  _drawConifer(c) {
    const x    = this.x;
    const topY = groundY - this.curH;
    const tw   = this.trunkHW;

    ctx.fillStyle = this._barkColor();
    ctx.fillRect(x - tw, topY + this.curH * 0.10, tw * 2, this.curH * 0.90);

    const maxHW   = this.genes.g * 15 + 8;
    const secH    = this.curH * 0.38;
    const stepY   = this.curH * 0.28;
    const cols    = [c.light, c.mid, c.dark];
    const sr      = this.genes.sr;
    const coneLen = 4 + sr * 10;       // cone body length 4‚Äì14px
    const coneW   = 1.8 + sr * 3.5;   // cone width 1.8‚Äì5.3px
    const coneCol = `rgba(165,85,15,${(0.5 + sr * 0.48).toFixed(2)})`;

    for (let i = 0; i < 3; i++) {
      const ly = topY + i * stepY;
      const hw = maxHW * ((i + 1) / 3);
      ctx.fillStyle = cols[i];
      ctx.beginPath();
      ctx.moveTo(x, ly); ctx.lineTo(x + hw, ly + secH); ctx.lineTo(x - hw, ly + secH);
      ctx.closePath(); ctx.fill();

      // Serotiny: elongated brown cones hanging from branch tips
      if (sr > 0.05) {
        ctx.fillStyle = coneCol;
        const positions = [-hw * 0.7, 0, hw * 0.7];
        for (const px of positions) {
          ctx.beginPath();
          ctx.ellipse(x + px, ly + secH * 0.78, coneW, coneLen, 0, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
  }

  _drawDeciduous(c) {
    const x   = this.x;
    const crx = this.canopyRX;
    const cry = this.canopyRY;
    const cy  = groundY - this.curH;
    const tw  = this.trunkHW;

    // Bark thickness darkens the trunk
    const bark  = this._barkColor();
    const tGrad = ctx.createLinearGradient(x - tw, 0, x + tw, 0);
    tGrad.addColorStop(0,   '#1a0a02');
    tGrad.addColorStop(0.4, bark);
    tGrad.addColorStop(0.6, bark);
    tGrad.addColorStop(1,   '#1a0a02');
    ctx.fillStyle = tGrad;
    ctx.fillRect(x - tw, cy + cry * 0.5, tw * 2, groundY - cy - cry * 0.5);

    const grad = ctx.createRadialGradient(
      x - crx * 0.2, cy - cry * 0.25, crx * 0.04,
      x,             cy + cry * 0.15, crx
    );
    grad.addColorStop(0,    c.light);
    grad.addColorStop(0.55, c.mid);
    grad.addColorStop(1,    c.dark);
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.ellipse(x, cy, crx, cry, 0, 0, Math.PI * 2);
    ctx.fill();

    for (const b of this.bumps) {
      ctx.fillStyle = b.dy < -0.5 ? c.light : c.mid;
      ctx.beginPath();
      ctx.arc(x + b.dx * crx * 0.52, cy + b.dy * cry, cry * b.r, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.fillStyle = 'rgba(255,255,255,0.055)';
    ctx.beginPath();
    ctx.ellipse(x - crx * 0.18, cy - cry * 0.30, crx * 0.44, cry * 0.30, -0.2, 0, Math.PI * 2);
    ctx.fill();

    // Serotiny: dark seed-pod clusters scattered on canopy surface
    const sr = this.genes.sr;
    if (sr > 0.05) {
      const numPods  = 3 + Math.round(sr * 10);
      const podR     = 2.5 + sr * 3.5;
      ctx.fillStyle  = `rgba(80,40,8,${(0.45 + sr * 0.5).toFixed(2)})`;
      for (let i = 0; i < numPods; i++) {
        const angle = (i / numPods) * Math.PI * 2;
        const px2   = x + Math.cos(angle) * crx * 0.60;
        const py2   = cy + Math.sin(angle) * cry * 0.55;
        ctx.beginPath();
        ctx.arc(px2, py2, podR, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }
}

// ‚îÄ‚îÄ‚îÄ FALLING TREE (visual animation) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class FallingTree {
  constructor(tree) {
    this.x    = tree.x;
    this.gY   = groundY;
    this.curH = tree.curH;
    this.genes = { ...tree.genes };
    this.bumps = tree.bumps;
    this._c   = tree.colors();
    this.sr   = tree.shapeRatio;
    this.trW  = tree.trunkHW;
    this.crx  = tree.canopyRX;
    this.cry  = tree.canopyRY;
    this.angle      = 0;
    this.fallDir    = CFG.windDir >= 0 ? 1 : -1;
    this.done       = false;
    this._stumpMade = false;
  }

  update() {
    this.angle += Math.PI / 2 / 40;  // 40 render frames to fall
    if (this.angle >= Math.PI / 2) {
      this.angle = Math.PI / 2;
      if (!this._stumpMade) {
        this._stumpMade = true;
        stumps.push({
          x:      this.x + this.fallDir * this.curH * 0.3,
          w:      this.trW * 2 + 2,
          h:      Math.min(this.curH * 0.12, 18),
          age:    0,
          maxAge: 2000 + Math.random() * 1000,
        });
      }
      this.done = true;
    }
  }

  draw() {
    const c    = this._c;
    const curH = this.curH;
    ctx.save();
    ctx.translate(this.x, this.gY);
    ctx.rotate(this.fallDir * this.angle);

    if (this.sr > 2.0) {
      // Conifer in local space (base at 0,0, top at 0,-curH)
      ctx.fillStyle = '#3e1e08';
      ctx.fillRect(-this.trW, -curH * 0.9, this.trW * 2, curH * 0.9);
      const maxHW = this.genes.g * 15 + 8;
      const secH  = curH * 0.38;
      const stepY = curH * 0.28;
      const cols  = [c.light, c.mid, c.dark];
      for (let i = 0; i < 3; i++) {
        const ly = -curH + i * stepY;
        const hw = maxHW * ((i + 1) / 3);
        ctx.fillStyle = cols[i];
        ctx.beginPath();
        ctx.moveTo(0, ly); ctx.lineTo(hw, ly + secH); ctx.lineTo(-hw, ly + secH);
        ctx.closePath(); ctx.fill();
      }
    } else {
      // Deciduous in local space
      const crx = this.crx, cry = this.cry, tw = this.trW;
      ctx.fillStyle = '#3e1e08';
      ctx.fillRect(-tw, -(curH - cry * 0.5), tw * 2, curH - cry * 0.5);

      const grad = ctx.createRadialGradient(
        -crx * 0.2, -curH - cry * 0.25, crx * 0.04,
        0,          -curH + cry * 0.15, crx
      );
      grad.addColorStop(0,    c.light);
      grad.addColorStop(0.55, c.mid);
      grad.addColorStop(1,    c.dark);
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.ellipse(0, -curH, crx, cry, 0, 0, Math.PI * 2);
      ctx.fill();

      for (const b of this.bumps) {
        ctx.fillStyle = b.dy < -0.5 ? c.light : c.mid;
        ctx.beginPath();
        ctx.arc(b.dx * crx * 0.52, -curH + b.dy * cry, cry * b.r, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    ctx.restore();
  }
}

// ‚îÄ‚îÄ‚îÄ LIGHT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function computeLight() {
  const light = new Float32Array(numSlots).fill(1.0);
  for (let j = 0; j < numSlots; j++) {
    const t = slots[j];
    if (!t || t.curH < 6) continue;
    const hFrac = t.curH / maxTreeH;
    const reach = Math.ceil(t.canopyRX / CFG.slotW);
    for (let di = -reach; di <= reach; di++) {
      const i = j + di;
      if (i < 0 || i >= numSlots || i === j) continue;
      const distF  = Math.abs(di) / (reach + 0.5);
      const shadow = hFrac * (1 - distF) * 0.88;
      if (shadow > 1 - light[i]) light[i] = Math.max(0, 1 - shadow);
    }
  }
  return light;
}

// ‚îÄ‚îÄ‚îÄ FIRE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function igniteSlot(slot) {
  if (activeFires.has(slot)) return;
  const t = slots[slot];
  if (!t) return;
  // Bark thickness is the primary fire defence; girth adds a little
  const fireResist = t.genes.b * t.genes.b * 0.65 + t.genes.g * t.genes.g * 0.10;
  if (Math.random() < fireResist) return;
  // Thicker bark also slows burning
  const burnTime = 55 + t.genes.b * 120 + t.genes.g * 20 + Math.random() * 35;
  activeFires.set(slot, { age: 0, burnTime });
}

function triggerFire() {
  const cx  = (Math.random() * numSlots) | 0;
  const rad = 2 + ((Math.random() * 4) | 0);
  for (let i = cx - rad; i <= cx + rad; i++) {
    if (i >= 0 && i < numSlots && slots[i]) igniteSlot(i);
  }
}

// ‚îÄ‚îÄ‚îÄ SEED PLANTING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function plantSeed(slot, genes, seedSize) {
  if (slot < 0 || slot >= numSlots || slots[slot]) return false;
  const light     = lightArr[slot] ?? 1.0;
  const shadeFact = light < 0.4 ? (seedSize * light / 0.4) : 1.0;

  // Allelopathy: nearby trees exude chemicals that suppress germination
  let suppression = 0;
  const reach = 3;
  for (let di = -reach; di <= reach; di++) {
    const ni = slot + di;
    if (ni < 0 || ni >= numSlots || !slots[ni]) continue;
    const distFrac = Math.abs(di) / (reach + 1);
    suppression = Math.max(suppression, slots[ni].genes.a * (1 - distFrac) * 0.85);
  }

  if (Math.random() < 0.28 * shadeFact * (1 - suppression)) {
    slots[slot] = new Tree(slot, genes);
    return true;
  }
  return false;
}

// ‚îÄ‚îÄ‚îÄ SIMULATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function simulate() {
  // Wind direction drifts slowly
  CFG.windDir = clamp(CFG.windDir + (Math.random() - 0.5) * 0.025, -1, 1);

  lightArr = computeLight();

  // Random fire events
  if (CFG.fireRate > 0 && Math.random() < CFG.fireRate * 0.0015) triggerFire();

  // Process active fires: spread, age, and eventually kill trees
  for (const [slot, fire] of activeFires) {
    fire.age++;

    // Spread to adjacent slots every 25 frames
    if (fire.age % 25 === 0) {
      for (const di of [-1, 1]) {
        const ns = slot + di;
        if (ns >= 0 && ns < numSlots && slots[ns] && !activeFires.has(ns)) {
          if (Math.random() < 0.65) igniteSlot(ns);
        }
      }
    }

    // Kill tree when fully burned
    if (fire.age >= fire.burnTime) {
      const t = slots[slot];
      if (t) {
        // Serotiny: heat opens cones ‚Äî dump entire seed cache into bank
        for (const s of t.seedCache) {
          if (seedBank.length < MAX_SEED_BANK)
            seedBank.push({ slot: s.slot, genes: s.genes, seedSize: s.seedSize, age: 0 });
        }
        stumps.push({
          x: t.x, w: t.trunkHW * 2 + 2,
          h: Math.min(t.curH * 0.22, 28),
          age: 0, maxAge: 2500 + Math.random() * 1200,
        });
        slots[slot] = null;
      }
      activeFires.delete(slot);
    }
  }

  // Age stumps
  for (let i = stumps.length - 1; i >= 0; i--) {
    stumps[i].age++;
    if (stumps[i].age > stumps[i].maxAge) stumps.splice(i, 1);
  }

  // Update trees (skip burning ones)
  const pending = [];
  for (let i = 0; i < numSlots; i++) {
    if (!slots[i] || activeFires.has(i)) continue;
    const seeds = slots[i].update(lightArr[i]);
    if (slots[i].dead) {
      if (slots[i].windToppled) {
        fallingTrees.push(new FallingTree(slots[i]));
      }
      slots[i] = null;
      continue;
    }
    for (const s of seeds) pending.push(s);
  }

  // Shuffle seeds to avoid positional bias
  for (let i = pending.length - 1; i > 0; i--) {
    const j = (Math.random() * (i + 1)) | 0;
    [pending[i], pending[j]] = [pending[j], pending[i]];
  }

  // Add seeds to bank (not planted immediately ‚Äî they decay over time)
  for (const s of pending) {
    if (s.slot >= 0 && s.slot < numSlots && seedBank.length < MAX_SEED_BANK) {
      seedBank.push({ slot: s.slot, genes: s.genes, seedSize: s.seedSize, age: 0 });
    }
  }

  // Process seed bank: age seeds, attempt germination, remove dead seeds
  for (let i = seedBank.length - 1; i >= 0; i--) {
    const seed = seedBank[i];
    seed.age++;
    const viability = Math.exp(-seed.age / SEED_HALFLIFE);
    if (viability < SEED_MIN_VIA) { seedBank.splice(i, 1); continue; }
    if (Math.random() < viability * 0.003) {
      if (plantSeed(seed.slot, seed.genes, seed.seedSize)) {
        seedBank.splice(i, 1);
      }
    }
  }

  frameCount++;
}

// ‚îÄ‚îÄ‚îÄ VISUAL: WIND PARTICLES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function initWindParticles() {
  windParticles = Array.from({ length: 35 }, () => ({
    x: Math.random() * canvas.width,
    y: Math.random() * groundY * 0.80 + 10,
  }));
}

function drawWindParticles() {
  if (CFG.windStr < 0.05) return;
  const absDir = Math.abs(CFG.windDir);
  if (absDir < 0.05) return;

  const W    = canvas.width;
  const dir  = CFG.windDir > 0 ? 1 : -1;
  const spd  = absDir * CFG.windStr * 4.5 + 0.4;
  const size = 8 + CFG.windStr * 24;
  const op   = (0.12 + CFG.windStr * 0.5).toFixed(2);
  const lw   = 0.7 + CFG.windStr * 1.6;

  ctx.strokeStyle = `rgba(210,235,255,${op})`;
  ctx.lineWidth   = lw;

  for (const p of windParticles) {
    p.x += dir * spd;
    if (p.x > W + 50) p.x = -50;
    if (p.x < -50)    p.x = W + 50;

    const x0 = p.x - dir * size * 0.5;
    const x1 = p.x + dir * size * 0.5;
    ctx.beginPath();
    ctx.moveTo(x0, p.y);
    ctx.lineTo(x1, p.y);
    ctx.lineTo(x1 - dir * 7, p.y - 4);
    ctx.moveTo(x1, p.y);
    ctx.lineTo(x1 - dir * 7, p.y + 4);
    ctx.stroke();
  }
}

// ‚îÄ‚îÄ‚îÄ VISUAL: RAIN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawRain(W, H) {
  if (CFG.rainfall < 0.05) return;

  const target = Math.floor(CFG.rainfall * 180);
  while (raindrops.length < target)
    raindrops.push({ x: Math.random() * W, y: Math.random() * H,
                     len: 8 + Math.random() * 8, spd: 6 + Math.random() * 4 });
  while (raindrops.length > target) raindrops.pop();

  const drift = CFG.windDir * CFG.windStr * 0.45;
  const alpha = (0.3 + CFG.rainfall * 0.5).toFixed(2);

  ctx.strokeStyle = `rgba(210,235,255,${alpha})`;
  ctx.lineWidth   = 1.2;
  ctx.beginPath();
  for (const d of raindrops) {
    d.y += d.spd;
    d.x += drift * d.spd * 0.5;
    if (d.y > H) { d.y = -10; d.x = Math.random() * W; }
    if (d.x > W + 10) d.x = -10;
    if (d.x < -10)    d.x = W + 10;
    ctx.moveTo(d.x, d.y);
    ctx.lineTo(d.x + drift * d.len, d.y + d.len);
  }
  ctx.stroke();
}

// ‚îÄ‚îÄ‚îÄ VISUAL: FLAMES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawFlames(slot) {
  const fire = activeFires.get(slot);
  if (!fire) return;

  const x = (slot + 0.5) * CFG.slotW;
  const t = slots[slot];
  const h = (t ? t.curH : 30) * 0.65;

  const progress  = fire.age / fire.burnTime;
  const intensity = Math.min(1, progress < 0.6 ? progress / 0.6 : (1 - progress) / 0.4);

  for (let i = 0; i < 4; i++) {
    const phase = animFrame * 0.11 + i * 1.5;
    const offX  = Math.sin(phase) * 5;
    const flH   = h * (0.35 + 0.2 * Math.sin(phase * 0.7)) * intensity;
    if (flH < 2) continue;

    const grad = ctx.createLinearGradient(x + offX, groundY, x + offX, groundY - flH);
    grad.addColorStop(0,   'rgba(255,55,0,0.88)');
    grad.addColorStop(0.4, 'rgba(255,155,0,0.65)');
    grad.addColorStop(1,   'rgba(255,255,80,0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.moveTo(x + offX - 5, groundY);
    ctx.quadraticCurveTo(x + offX + 4, groundY - flH * 0.5, x + offX, groundY - flH);
    ctx.quadraticCurveTo(x + offX - 4, groundY - flH * 0.5, x + offX + 5, groundY);
    ctx.fill();
  }

  // Orange ambient glow
  const gr = h * 0.8;
  const glow = ctx.createRadialGradient(x, groundY - h * 0.25, 0, x, groundY - h * 0.25, gr);
  glow.addColorStop(0, `rgba(255,110,0,${(0.14 * intensity).toFixed(2)})`);
  glow.addColorStop(1, 'rgba(255,50,0,0)');
  ctx.fillStyle = glow;
  ctx.fillRect(x - gr, groundY - h, gr * 2, h);
}

// ‚îÄ‚îÄ‚îÄ AVERAGE TREE PREVIEW ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawAverageTree() {
  const live = slots.filter(Boolean);
  const pc   = document.getElementById('preview');
  const px   = pc.getContext('2d');
  const PW   = pc.width, PH = pc.height;

  // Mini sky + ground matching main scene proportions
  const pgY  = Math.floor(PH * CFG.groundFrac);
  const pmH  = Math.floor(pgY * 0.86);  // max tree height in preview

  const sky = px.createLinearGradient(0, 0, 0, pgY);
  sky.addColorStop(0,   '#2b65b0');
  sky.addColorStop(0.5, '#68a8da');
  sky.addColorStop(1,   '#bcdcee');
  px.fillStyle = sky;
  px.fillRect(0, 0, PW, pgY);

  const gnd = px.createLinearGradient(0, pgY, 0, PH);
  gnd.addColorStop(0,   '#58982e');
  gnd.addColorStop(0.4, '#386a20');
  gnd.addColorStop(1,   '#265018');
  px.fillStyle = gnd;
  px.fillRect(0, pgY, PW, PH - pgY);

  if (!live.length) {
    px.fillStyle = 'rgba(180,230,140,0.45)';
    px.font = '11px Segoe UI, sans-serif';
    px.textAlign = 'center';
    px.fillText('no trees', PW / 2, pgY - 10);
    return;
  }

  // Compute averages
  let sh = 0, sg = 0, scw = 0, ss = 0, sr_ = 0, sb = 0;
  for (const t of live) {
    sh += t.genes.h; sg += t.genes.g; scw += t.genes.cw;
    ss += t.genes.s; sr_ += t.genes.r; sb += t.genes.b;
  }
  const n   = live.length;
  const ah  = sh / n, ag = sg / n, acw = scw / n;
  const as_ = ss / n, ar = sr_ / n, ab = sb / n;

  // Derived sizing (same formulas as Tree class)
  const shapeRatio = ah / (ag + 0.1);
  const curH = ah * pmH;
  const topY = pgY - curH;
  const tw   = shapeRatio > 2.0 ? Math.max(1.5, ag * 4) : Math.max(3, ag * 11);
  const crx  = Math.min(PW * 0.44, acw * 54 + 8);  // use cw gene
  const cry  = Math.min(48, curH * 0.17 + 5);
  const tx   = PW / 2;

  // Colours (matches Tree.colors() formula)
  const cr = Math.round(10  + as_ * 100);
  const cg = Math.round(55  + as_ * 125);
  const cb = Math.round(8   + as_ * 10);
  const cLight = `rgb(${cr+42},${cg+42},${cb+14})`;
  const cMid   = `rgb(${cr},${cg},${cb})`;
  const cDark  = `rgb(${Math.round(cr*0.38)},${Math.round(cg*0.38)},${Math.round(cb*0.38)})`;

  // Average bark color for preview trunk (matches new extreme range)
  const barkR   = Math.round(200 - ab * 172);
  const barkG   = Math.round(155 - ab * 143);
  const barkBv  = Math.round(80  - ab * 76);
  const barkCol = `rgb(${barkR},${barkG},${barkBv})`;

  // Roots (visible below ground)
  if (ar > 0.15) {
    const rootDepth = ar * 22;
    const numRoots  = 2 + Math.round(ar * 2);
    px.strokeStyle  = `rgba(50,24,6,${(0.25 + ar * 0.45).toFixed(2)})`;
    px.lineWidth    = 1;
    for (let i = 0; i < numRoots; i++) {
      const spread = ((i / (numRoots - 1 || 1)) - 0.5) * 2;
      const endX   = tx + spread * (tw * 2 + ar * 14);
      px.beginPath();
      px.moveTo(tx + spread * tw, pgY);
      px.quadraticCurveTo(tx + spread * tw * 1.5, pgY + rootDepth * 0.4, endX, pgY + rootDepth);
      px.stroke();
    }
  }

  // Ground shadow ellipse
  px.fillStyle = `rgba(0,22,0,${(0.16 * ah).toFixed(3)})`;
  px.beginPath();
  px.ellipse(tx, pgY + 3, crx * 1.1, 5, 0, 0, Math.PI * 2);
  px.fill();

  if (shapeRatio > 2.0) {
    // Conifer
    px.fillStyle = barkCol;
    px.fillRect(tx - tw, topY + curH * 0.10, tw * 2, curH * 0.90);

    const maxHW = ag * 15 + 8;
    const secH  = curH * 0.38;
    const stepY = curH * 0.28;
    const cols  = [cLight, cMid, cDark];
    for (let i = 0; i < 3; i++) {
      const ly = topY + i * stepY;
      const hw = Math.min(maxHW * ((i + 1) / 3), PW * 0.45);
      px.fillStyle = cols[i];
      px.beginPath();
      px.moveTo(tx, ly); px.lineTo(tx + hw, ly + secH); px.lineTo(tx - hw, ly + secH);
      px.closePath(); px.fill();
    }
  } else {
    // Deciduous
    const cy = pgY - curH;

    // Trunk (bark color reflects avg bark thickness)
    const tg = px.createLinearGradient(tx - tw, 0, tx + tw, 0);
    tg.addColorStop(0,   '#1a0a02');
    tg.addColorStop(0.4, barkCol);
    tg.addColorStop(0.6, barkCol);
    tg.addColorStop(1,   '#1a0a02');
    px.fillStyle = tg;
    px.fillRect(tx - tw, cy + cry * 0.5, tw * 2, pgY - cy - cry * 0.5);

    // Canopy
    const grad = px.createRadialGradient(
      tx - crx * 0.2, cy - cry * 0.25, crx * 0.04,
      tx,             cy + cry * 0.15, crx
    );
    grad.addColorStop(0,    cLight);
    grad.addColorStop(0.55, cMid);
    grad.addColorStop(1,    cDark);
    px.fillStyle = grad;
    px.beginPath();
    px.ellipse(tx, cy, crx, cry, 0, 0, Math.PI * 2);
    px.fill();

    // Specular
    px.fillStyle = 'rgba(255,255,255,0.055)';
    px.beginPath();
    px.ellipse(tx - crx * 0.18, cy - cry * 0.30, crx * 0.44, cry * 0.30, -0.2, 0, Math.PI * 2);
    px.fill();
  }
}

// ‚îÄ‚îÄ‚îÄ DRAW FRAME ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawFrame() {
  const W = canvas.width, H = canvas.height;

  // Sky gradient
  const sky = ctx.createLinearGradient(0, 0, 0, groundY);
  sky.addColorStop(0,   '#2b65b0');
  sky.addColorStop(0.5, '#68a8da');
  sky.addColorStop(1,   '#bcdcee');
  ctx.fillStyle = sky;
  ctx.fillRect(0, 0, W, groundY);

  // Wind arrow particles (in sky, behind hills)
  drawWindParticles();

  // Distant hills silhouette
  ctx.fillStyle = 'rgba(42, 88, 42, 0.38)';
  ctx.beginPath();
  ctx.moveTo(0, groundY);
  for (let x = 0; x <= W; x += 5) {
    const hv = 34 * Math.sin(x * 0.007) + 20 * Math.sin(x * 0.013 + 1.4)
             + 16 * Math.sin(x * 0.004 + 2.9);
    ctx.lineTo(x, groundY - 44 + hv);
  }
  ctx.lineTo(W, groundY);
  ctx.closePath();
  ctx.fill();

  // Rain (in front of hills)
  drawRain(W, H);

  // Shadow stripes on ground ‚Äî light system visible
  for (let i = 0; i < numSlots; i++) {
    const shade = 1 - (lightArr[i] ?? 1);
    if (shade > 0.04) {
      ctx.fillStyle = `rgba(0,18,0,${(shade * 0.48).toFixed(3)})`;
      ctx.fillRect(i * CFG.slotW, groundY - 4, CFG.slotW, 22);
    }
  }

  // Ground
  const gnd = ctx.createLinearGradient(0, groundY, 0, H);
  gnd.addColorStop(0,    '#58982e');
  gnd.addColorStop(0.12, '#488228');
  gnd.addColorStop(0.4,  '#386a20');
  gnd.addColorStop(1,    '#265018');
  ctx.fillStyle = gnd;
  ctx.fillRect(0, groundY, W, H - groundY);

  // Charred stumps
  for (const s of stumps) {
    const op = 1 - s.age / s.maxAge;
    ctx.fillStyle = `rgba(22,10,4,${(op * 0.92).toFixed(3)})`;
    ctx.fillRect(s.x - s.w / 2, groundY - s.h, s.w, s.h);
    ctx.fillStyle = `rgba(0,0,0,${(op * 0.45).toFixed(3)})`;
    ctx.fillRect(s.x - s.w / 2 + 1, groundY - s.h + 2, 1, s.h - 2);
    ctx.fillRect(s.x + s.w / 2 - 2, groundY - s.h + 3, 1, s.h - 3);
  }

  // Ground shadow ellipses under canopies
  for (let i = 0; i < numSlots; i++) {
    const t = slots[i];
    if (!t) continue;
    const op = 0.16 * (t.curH / maxTreeH);
    ctx.fillStyle = `rgba(0,22,0,${op.toFixed(3)})`;
    ctx.beginPath();
    ctx.ellipse(t.x, groundY + 5, t.canopyRX * 1.1, 6, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Falling trees (visual animation)
  for (let i = fallingTrees.length - 1; i >= 0; i--) {
    fallingTrees[i].update();
    fallingTrees[i].draw();
    if (fallingTrees[i].done) fallingTrees.splice(i, 1);
  }

  // Dispersal radius arc ‚Äî thin blue semicircle on ground for each tree
  ctx.lineWidth = 0.9;
  for (let i = 0; i < numSlots; i++) {
    const t = slots[i];
    if (!t || t.genes.d < 3) continue;
    const radius = t.genes.d * CFG.slotW;
    const op     = 0.06 + (t.genes.d / CFG.dRange[1]) * 0.18;
    ctx.strokeStyle = `rgba(128,200,224,${op.toFixed(2)})`;
    ctx.beginPath();
    ctx.arc(t.x, groundY, radius, Math.PI, Math.PI * 2);  // upper half (into sky)
    ctx.stroke();
  }

  // Allelopathy: sickly yellow-brown dead zone + dead-grass marks
  for (let i = 0; i < numSlots; i++) {
    const t = slots[i];
    if (!t || t.genes.a < 0.05) continue;
    const reach = t.genes.a * 3 * CFG.slotW;
    const op    = 0.12 + t.genes.a * 0.50;
    // Dead zone fill
    ctx.fillStyle = `rgba(148,122,18,${op.toFixed(3)})`;
    ctx.beginPath();
    ctx.ellipse(t.x, groundY + 4, reach, 10, 0, 0, Math.PI * 2);
    ctx.fill();
    // Deterministic dead-grass strokes
    if (t.genes.a > 0.2) {
      const numMarks = 2 + Math.round(t.genes.a * 8);
      ctx.strokeStyle = `rgba(110,88,10,${(op * 0.75).toFixed(3)})`;
      ctx.lineWidth   = 1;
      for (let m = 0; m < numMarks; m++) {
        const mx = t.x + (m / numMarks - 0.5) * reach * 1.7;
        const mh = 5 + ((i * 7 + m * 13) % 7);
        const mx2 = mx + ((i + m * 3) % 5 - 2) * 1.5;
        ctx.beginPath();
        ctx.moveTo(mx, groundY);
        ctx.lineTo(mx2, groundY - mh);
        ctx.stroke();
      }
    }
  }

  // Standing trees
  for (let i = 0; i < numSlots; i++) {
    if (slots[i]) slots[i].draw();
  }

  // Flames over burning trees
  for (const slot of activeFires.keys()) {
    drawFlames(slot);
  }

  // Average tree preview
  drawAverageTree();
}

// ‚îÄ‚îÄ‚îÄ STATS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateStats() {
  const live = slots.filter(Boolean);
  const n    = live.length;

  document.getElementById('s-pop').textContent   = n;
  document.getElementById('s-seeds').textContent = seedBank.length;
  document.getElementById('s-time').textContent  = frameCount;

  if (!n) return;
  let sh = 0, sg = 0, scw = 0, ss = 0, sd = 0, sr_ = 0, sb = 0, sa = 0, ssr = 0;
  for (const t of live) {
    sh += t.genes.h; sg += t.genes.g; scw += t.genes.cw;
    ss += t.genes.s; sd += t.genes.d;
    sr_ += t.genes.r; sb += t.genes.b; sa += t.genes.a; ssr += t.genes.sr;
  }

  document.getElementById('s-h').textContent  = (sh  /n).toFixed(2);
  document.getElementById('s-g').textContent  = (sg  /n).toFixed(2);
  document.getElementById('s-cw').textContent = (scw /n).toFixed(2);
  document.getElementById('s-r').textContent  = (sr_ /n).toFixed(2);
  document.getElementById('s-b').textContent  = (sb  /n).toFixed(2);
  document.getElementById('s-s').textContent  = (ss  /n).toFixed(2);
  document.getElementById('s-d').textContent  = (sd  /n).toFixed(1);
  document.getElementById('s-a').textContent  = (sa  /n).toFixed(2);
  document.getElementById('s-sr').textContent = (ssr /n).toFixed(2);

  history.push({
    pop: n / numSlots,
    h:   sh  / n,
    g:   sg  / n,
    cw:  scw / n,
    r:   sr_ / n,
    b:   sb  / n,
    s:   ss  / n,
    d:   (sd / n) / CFG.dRange[1],
    a:   sa  / n,
    sr:  ssr / n,
  });
  if (history.length > MAX_HIST) history.shift();
  drawGraph('graph-phys',  [
    { key:'h',   color:'#6dbf4a', lw:1.5 },
    { key:'g',   color:'#a07850', lw:1.5 },
    { key:'cw',  color:'#b088e0', lw:1.5 },
    { key:'r',   color:'#5bc8a0', lw:1   },
    { key:'b',   color:'#d08840', lw:1   },
    { key:'pop', color:'#ffffff', lw:1   },
  ]);
  drawGraph('graph-strat', [
    { key:'s',   color:'#e8d060', lw:1.5 },
    { key:'d',   color:'#80c8e0', lw:1.5 },
    { key:'a',   color:'#c8a030', lw:1.5 },
    { key:'sr',  color:'#e07050', lw:1.5 },
    { key:'pop', color:'#ffffff', lw:1   },
  ]);
}

function drawGraph(id, lines) {
  const gc = document.getElementById(id);
  const gx = gc.getContext('2d');
  const W  = gc.width, H = gc.height;
  gx.clearRect(0, 0, W, H);
  gx.fillStyle = 'rgba(0,0,0,0.38)';
  gx.fillRect(0, 0, W, H);
  if (history.length < 2) return;

  const vis = history.slice(-150);
  for (const l of lines) {
    gx.strokeStyle = l.color;
    gx.lineWidth   = l.lw;
    gx.beginPath();
    for (let i = 0; i < vis.length; i++) {
      const x = (i / (vis.length - 1)) * W;
      const y = H - vis[i][l.key] * H;
      i === 0 ? gx.moveTo(x, y) : gx.lineTo(x, y);
    }
    gx.stroke();
  }
}

// ‚îÄ‚îÄ‚îÄ GAME LOOP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function loop() {
  for (let i = 0; i < CFG.simSpeed; i++) {
    simulate();
    if (frameCount % 60 === 0) updateStats();
  }
  drawFrame();
  animFrame++;
  requestAnimationFrame(loop);
}

// ‚îÄ‚îÄ‚îÄ UI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function initUI() {
  const uiEl = document.getElementById('ui');
  document.getElementById('tog').addEventListener('click', () => {
    uiEl.classList.toggle('collapsed');
    document.getElementById('tog').textContent =
      uiEl.classList.contains('collapsed') ? '‚ñº' : '‚ñ≤';
  });

  const bind = (sliderId, cfgKey, dispId, fmt) => {
    document.getElementById(sliderId).addEventListener('input', e => {
      CFG[cfgKey] = fmt(e.target.value);
      document.getElementById(dispId).textContent =
        cfgKey === 'simSpeed' ? CFG[cfgKey] + '√ó' : CFG[cfgKey].toFixed(2);
    });
  };

  bind('sl-rain',  'rainfall', 'd-rain',  parseFloat);
  bind('sl-wind',  'windStr',  'd-wind',  parseFloat);
  bind('sl-fire',  'fireRate', 'd-fire',  parseFloat);
  bind('sl-mut',   'mutRate',  'd-mut',   parseFloat);
  bind('sl-speed', 'simSpeed', 'd-speed', parseInt);

  document.getElementById('btn-reset').addEventListener('click', resetSim);
}

// ‚îÄ‚îÄ‚îÄ RESIZE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function resize() {
  canvas.width  = window.innerWidth;
  canvas.height = window.innerHeight;
  groundY  = Math.floor(canvas.height * CFG.groundFrac);
  maxTreeH = Math.floor(groundY * 0.86);
  numSlots = Math.floor(canvas.width / CFG.slotW);

  // Preview window: ~quarter screen height, fixed width, top-right
  const pc = document.getElementById('preview');
  const pw = document.getElementById('preview-wrap');
  const previewW = 160;
  const previewH = Math.floor(window.innerHeight * 0.26);
  pc.width  = previewW;
  pc.height = previewH;
  pw.style.width  = previewW + 'px';
  pw.style.height = previewH + 'px';
}

function initParticles() {
  windParticles = Array.from({ length: 35 }, () => ({
    x: Math.random() * canvas.width,
    y: Math.random() * groundY * 0.80 + 10,
  }));
  raindrops = [];
}

// ‚îÄ‚îÄ‚îÄ RESET ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function resetSim() {
  slots        = new Array(numSlots).fill(null);
  lightArr     = new Float32Array(numSlots).fill(1.0);
  stumps       = [];
  fallingTrees = [];
  activeFires  = new Map();
  seedBank     = [];
  history      = [];
  frameCount   = 0;
  animFrame    = 0;
  initParticles();
  for (let i = 0; i < 25; i++) {
    const slot = (Math.random() * numSlots) | 0;
    if (!slots[slot]) slots[slot] = new Tree(slot);
  }
}

// ‚îÄ‚îÄ‚îÄ INIT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function init() {
  resize();
  window.addEventListener('resize', () => {
    resize();
    while (slots.length < numSlots) slots.push(null);
    slots.length = numSlots;
    lightArr = new Float32Array(numSlots).fill(1.0);
    initParticles();
  });

  slots    = new Array(numSlots).fill(null);
  lightArr = new Float32Array(numSlots).fill(1.0);

  for (let i = 0; i < 25; i++) {
    const slot = (Math.random() * numSlots) | 0;
    if (!slots[slot]) slots[slot] = new Tree(slot);
  }

  initParticles();
  initUI();
  loop();
}

init();
</script>
</body>
</html>
